//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// Google code style
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------


#include <vector>
#include <iostream>

// ЗАГОЛОВОЧНЫЕ ФАЙЛЫ
// В общем (за некторыми исключениями) каждые ccp-файл должен имет h-файл.

// Заголовочные файлы должны быть самостоятельными и заканчиваться на .h.
// Недолжно быть особых условий для включения h-файлы (за некоторым исключением).

// define Guard
// Все заголовки должны иметь эту защиту.

// Имя <PFOJECT>_<PATH>_<FILE>_H   
// foo/src/bar/baz.h :
#ifndef FOO_SRC_BAR_BAZ_H
#define FOO_SRC_BAR_BAZ_H
// Содержимое h-файла.
#endif


// Не использовать транзитивныые вкючения.

// Избегать использование предварительных определений.


//----------------------------------------------------------------------------
// делать функции inline если фукнции не больше 10 строк.
// встраивать гетеры(аксессоры) и сетеры(мутаторы) и другие короткие, важные для производительности функции.
// Полезно встраивать функции с циклами и switch.
// Виртуальные и рекурсивные функции не будут встраиваться.
// Но можно реализовать короткий метод в заголовочном классе, тогд он будет inline. 

inline int add(int a, int b) {
    return a + b;
}


//----------------------------------------------------------------------------
// Names and Order of includes

// Включать в следующем порядке:
// Связный заголовочный файл.
// Системные заголоыочные.
// C++ stl заголовочные.
// Заголовочные других библиотек.
// Заголовочные проекта.

// Делать пробелы между блоками включений.

// Угловые скобки: 
// 1. заголовочные файлы библиотек С и С++ (например, <stdlib.h> и <string>).
// 2. системные заголовочные POSIX, Linux, Windows (например, <unistd.h> и <windows.h>).
// 3. в редких случаях сторонние библиотеки (например <Python.h>).

// В файле dir/foo.cc или dir/foo_test.cc, который должен реализовать или тестировать вещи из dir2/foo2.h, упорядочьте включения следующим образом:
// dir2/foo2.h.

// Внутри каждого include-раздела, включения должны быть остортированны в алфавитном порядке

#include "foo/server/fooserver.h"

#include <sys/types.h>
#include <unistd.h>

#include <string>
#include <vector>

#include "base/basictypes.h"
#include "foo/server/bar.h"
#include "third_party/absl/flags/flag.h"


//----------------------------------------------------------------------------
// Scoping

// Namespace
// Размещать код в просртранства имен.
// Не использовать usin-директивы для всего namespace. 
// Завершать многострочные namespace комментариями

// не использовать inline namespace размещают свои символы в данной ОВ
// не объявлять ни чего в std

// использовать "internal" в названии для документирования частей API, которые не должны упоминаться пользователями API.
namespace mylibrary {
    namespace internal {

        class ImplementationDetail {
        // Внутренние детали реализации, не предназначенные для использования пользователями API.
        };

    }  // namespace internal
}  // namespace mylibrary


// Примеры структуры .h и .cc файлов
// -.h файл
namespace mynamespace {

class MyClass {
 public:
  void Foo();
};

}  // namespace mynamespace

// -.cpp файл
namespace mynamespace {

void MyClass::Foo() {
  ...
}

}  // namespace mynamespace

//----------------------------------------------------------------------------
// Internal Linkage (внутренняя связь)


// использовать или static или unamed namespace для внутреннего связывания в сс-файлах, но не в h-файлах.
// Такие объявления не доступны из других файлах.

// unnamed namespace
namespace {
    void say(const char* str) {
        std::cout << str << std::endl;
    }
} // namespase

//----------------------------------------------------------------------------
// Нечлены, статические члены и глобальные функции.

// Нечлены (за редким исключением) помещаются в namespase.
// Если функция нужна только в своем cc файле - использовать вутреннюю связь.


//----------------------------------------------------------------------------
// Локальные переменные 

// Объявлять переменные как можно ближе к использованию, и как можно более локальное ОВ.
// Использовать инициализацию при объявлении переменнойю
int i;
i = f(); // bad

int i = f(); // good


int jobs = NumJobs();
// some code ... 
f(jobs); // далеко от объявления

int jobs = NumJobs(); 
f(jobs);  // Близко к объявлению


std::vector<int> v;
v.push_back(1); // не верно
v.push_back(2);

std::vector<int> v = {1, 2}; // верно, лучше использовать инициализацию с использованием фигурных скобок

// Переменные для for и while объявлять в самих циклах
while(const char* p = strstr(str, '/'))
    str = p + 1;

// Не вставлять в циклы объекты классов

// Inefficient implementation:
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}

Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}