//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//-----------------------------------Тип--------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------


// Типы: value types (дипазон знач) & object types (опр. оп.).
// Имя связанно с типом - статическая типизация.
// У объекта есть адрес. bn 

int f() { return 42; }

const int& l = foo(); // объект на стеке



//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//------------------------------Имена и сущности------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

// Инвариант - утверждение, которое должно сохраняться на всем протяжении жизни объекта. 


//----------------------------------
// провисание ссылок.


// Время жизни переменной - совокупность всех моментов времени в программе, когда ее состояние валидно.
//      Сразу после инициализации.

const int& lx = 0; // продление жизни объекта при помощи const lvalue ref (создает объект)


// Временные объект живет до конца полного выражения
struct S {
    int x;
    const int& y;
};

S x{1, 2}; // OK
S* p = new S{1, 2}; // UB


//----------------------------------
// Decaing 

int foo(int& x) { return x; } // разложение ссылки до значения

void foo(int*);
int arr[5];
foo(arr); // разложение массива до указателя 

//----------------------------------
// Lvalue & rvalue

// C: lvalue left-hand-side value 
y = x; // x - lvalue, x - rvalue.

// C++: lvalue скорее location value.
int& foo();
foo() = x;

int* x[20];
int (*y)[20]; // указатель на массив
int (&z)[20] = *y; // ссылка на массив

char* (* (&c)[10])(int*&); // ссылка на массив указателей на функцию char* f(int*&)


// #################################################################
// генерируемые методы
/*
Конструктор по умолчанию: генерируется, если в классе не определено ни одного конструктора.

Деструктор: генерируется, если в классе не определен пользовательский деструктор.

Конструктор копирования: генерируется, если в классе не определены пользовательские конструктор
копирования, оператор присваивания копированием, конструктор перемещения, оператор присваивания
перемещением или деструктор.

Оператор присваивания копированием: генерируется, если в классе не определены пользовательские
конструктор копирования, оператор присваивания копированием, конструктор перемещения, оператор
присваивания перемещением или деструктор.

Конструктор перемещения: генерируется, если в классе не определены пользовательские конструктор
копирования, оператор присваивания копированием, конструктор перемещения, оператор присваивания
перемещением или деструктор.

Оператор присваивания перемещением: генерируется, если в классе не определены пользовательские
конструктор копирования, оператор присваивания копированием, конструктор перемещения, оператор
присваивания перемещением или деструктор.
*/
// #################################################################

//----------------------------------
// 200 iq список инициализации
class Buffer {
    int n; int* p; // порядок инициализации 1: n, 2: p
public:
    ....
    Buffer(const Buffer& oth) : n(oth.n), p(new int[n]) { // <<<<
        std::copy(p, p + n, oth.p);
    } 
}

//----------------------------------
// bad_alloc
#include <iostream>
#include <new>  // Для std::bad_alloc

int main() {
    try {
        // Попытка выделить огромное количество памяти
        int* p = new int[9999999999999999];
    } catch (const std::bad_alloc& e) {
        std::cerr << "Ошибка выделения памяти: " << e.what() << '\n';
    }
    return 0;
}
// необходимо учитывать в операторах присваивания.



//----------------------------------
// copy ctor v.s. implicit op
struct Foo {
    Foo(const Bar&) { print("Ctor Bar -> Foo"); }
};

struct Bar {
    Bar(const Foo&) { print("Ctor Foo -> Bar"); }
    operator Foo() {
        pritn("Op Bar -> Foo");
        return Foo{};
    }
};

int main() {
    Bar b;
    Foo f1(b); // direct-init, ctor                       // Ctor Bar -> Foo
    Foo f2 = b; // copy-init, ctor v.s. op, op wins.     // Op Bar -> Foo
}